# Ejercicio 6.5 — Principios SOLID (RA7.d,e,f,g)

Basado en la teoría de SOLID.

## Objetivo

Aplicar los **principios SOLID** sobre un código relacionado con la relación 6.4 (informes + personas), realizando refactors con sentido y demostrando comprensión mediante preguntas cortas por principio.

## Entregables en este repositorio

- **Código Kotlin** en `es.ies.ejercicios.u6.ej65` (se incluye código “v0” mejorable).
- **Documentación** en este fichero `docs/ejercicios/6.5.md`, con:
  - explicación de los cambios por principio,
  - evidencias (logs/salidas si aplica),
  - **enlaces permanentes** a los fragmentos de código que hayas modificado.

## Punto de partida (relación con 6.4)

El ejercicio usa la misma idea/dominio que 6.4: generar informes (CSV/Markdown) a partir de elementos “resumibles” (p. ej. personas/alumnos). Puedes reutilizar/clonar ideas o tipos del paquete `es.ies.ejercicios.u6.ej64` si lo necesitas.

## Ejercicios por principio

> Importante: en cada apartado debes (1) hacer un cambio de código y (2) responder preguntas para demostrar que entiendes el principio.

### S — SRP (Single Responsibility Principle)

**Código v0:** `es.ies.ejercicios.u6.ej65.srp`

Tarea:

- Identifica una clase/función que hace “demasiadas cosas”.
- Separa responsabilidades en tipos más pequeños (por ejemplo: normalización, formateo, persistencia, logging).
- Mantén un `main`/demo que pruebe el flujo.

Pista:

- Si una clase cambia por más de un motivo (cambiar el formato del informe, cambiar la regla de normalización, cambiar el logging, cambiar cómo se obtienen los datos), probablemente está violando SRP.
- En v0 fíjate en: preparación de datos + registro/normalización + generación de informe + salida por consola, todo junto. Intenta extraer al menos 2 componentes con nombres claros.

Preguntas:

1) ¿Qué responsabilidades tenía la versión v0?  

RESPUESTA:

2) ¿Qué clases/componentes has creado y qué responsabilidad tiene cada uno?

RESPUESTA:

3) ¿Cómo mejora el mantenimiento/testeo con el refactor?

RESPUESTA:


### O — OCP (Open/Closed Principle)

**Código v0:** `es.ies.ejercicios.u6.ej65.ocp`

Tarea:

- El generador v0 usa un `when` por “formato”.
- Refactoriza para que añadir un nuevo formato (p. ej. “HTML” o “JSON”) no requiera modificar el generador central.

Pista:

- Es normal que siga existiendo un punto donde “decides qué implementación crear” (CSV/Markdown/etc.).
- La idea de OCP es que esa decisión no obligue a modificar la **lógica principal** (el generador), sino que se haga fuera (por ejemplo en `main`, una factoría/registry o inyección de dependencias).

Preguntas:

1) ¿Qué parte violaba OCP y por qué?  

RESPUESTA:


2) ¿Qué técnica has usado (polimorfismo/estrategia/jerarquía) para cumplir OCP?

RESPUESTA:


3) ¿Cómo añadirías un nuevo formato tras tu refactor?

RESPUESTA:


### L — LSP (Liskov Substitution Principle)

**Código v0:** `es.ies.ejercicios.u6.ej65.lsp`

Tarea:

- Hay una jerarquía donde una subclase rompe expectativas del tipo padre (comportamiento inesperado).
- Refactoriza para que cualquier subclase pueda sustituir al padre sin “sorpresas” (sin lanzar excepciones inesperadas, sin romper invariantes).

Pista:

- Si una “subclase” no puede cumplir el contrato del padre (por ejemplo, “solo lectura” no puede `guardar`), normalmente no debe heredar de ese tipo.
- Una solución habitual es separar interfaces por capacidades (lectura vs escritura) o usar composición para exponer solo lo que realmente se puede hacer.

Preguntas:

1) ¿Qué comportamiento concreto violaba LSP?  

RESPUESTA:

2) ¿Qué cambio has hecho para asegurar sustitución válida?

RESPUESTA:

3) ¿Cómo lo demostrarías con una prueba/ejemplo?

RESPUESTA:


### I — ISP (Interface Segregation Principle)

**Código v0:** `es.ies.ejercicios.u6.ej65.isp`

Tarea:

- La interfaz v0 es “gorda” (métodos no usados por algunos clientes).
- Divídela en interfaces pequeñas y adapta los clientes para depender solo de lo que usan.

Pista:

- Empieza por el cliente más pequeño: si un cliente solo necesita `buscar(...)`, no debería depender de `exportarCsv()` ni `borrarTodo()`.
- Segrega por capacidades (por ejemplo: lectura, escritura, exportación, borrado) y haz que cada cliente dependa solo de lo que usa.
- Señal típica de violación: ganas de dejar métodos vacíos, lanzar `UnsupportedOperationException` o meter `TODO(...)` al implementar.

Nota (relación con LSP):

- ISP y LSP suelen aparecer juntas: una interfaz “gorda” puede forzar a ciertos tipos a prometer operaciones que realmente no pueden cumplir, lo que termina rompiendo la sustitución (LSP).
- Segregar por capacidades (por ejemplo, lectura vs escritura) ayuda a que los tipos implementen solo contratos que pueden respetar, mejorando el cumplimiento de LSP.

Preguntas:

1) ¿Qué métodos eran irrelevantes para algún cliente?  

RESPUESTA:


2) ¿Cómo has segregado la interfaz (nombres y responsabilidades)?

RESPUESTA:


3) ¿Qué mejora aporta a largo plazo?

RESPUESTA:


### D — DIP (Dependency Inversion Principle)

**Código v0:** `es.ies.ejercicios.u6.ej65.dip`

Tarea:

- Un módulo de alto nivel depende directamente de una implementación concreta.
- Refactoriza para que dependa de **abstracciones** e inyecte implementaciones (constructor recomendado).

Pista:

- “Alto nivel” = orquesta el caso de uso; “bajo nivel” = detalles concretos (CSV/Markdown, consola/archivo, etc.).
- Crea una abstracción (interfaz) que represente lo que necesitas (p. ej. `GeneradorInforme`), y pasa la implementación por **constructor**.
- Si para cambiar de CSV a Markdown tienes que editar la clase de alto nivel, aún no estás cumpliendo DIP.

Preguntas:

1) ¿Cuál era el detalle concreto del que dependía el módulo de alto nivel?  

RESPUESTA:

2) ¿Qué abstracción has creado/empleado?

RESPUESTA:

3) ¿Cómo intercambiarías implementaciones sin tocar el módulo de alto nivel?

RESPUESTA:


## Enlaces permanentes a código (obligatorio)

Incluye enlaces permanentes a:

- Cambios SRP (antes/después o v0 vs refactor).
- Cambios OCP (cómo añades el nuevo formato).
- Cambios LSP (dónde se arregla la sustitución).
- Cambios ISP (interfaces segregadas y cliente actualizado).
- Cambios DIP (abstracciones + inyección).

## Evidencias (salida por consola)

*(Opcional pero recomendado)* pega una salida breve por principio o un `main` que ejecute los 5 casos.

## Recursos

- Teoría (SOLID): https://revilofe.github.io/section1/u06/teoria/PROG-U6.3.-principiosSOLID/
- Enlaces permanentes a código (GitHub Docs): https://docs.github.com/es/get-started/writing-on-github/working-with-advanced-formatting/creating-a-permanent-link-to-a-code-snippet
